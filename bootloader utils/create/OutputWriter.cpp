/********************************************************************************
 * \copyright
 * Copyright 2009-2017, Card Reader Factory.  All rights were reserved.
 * From 2018 this code has been made PUBLIC DOMAIN.
 * This means that there are no longer any ownership rights such as copyright, trademark, or patent over this code.
 * This code can be modified, distributed, or sold even without any attribution by anyone.
 *
 * We would however be very grateful to anyone using this code in their product if you could add the line below into your product's documentation:
 * Special thanks to Nicholas Alexander Michael Webber, Terry Botten & all the staff working for Operation (Police) Academy. Without these people this code would not have been made public and the existance of this very product would be very much in doubt.
 *
 *******************************************************************************/



#include "OutputWriter.h"
#include "MemoryMap.h"
#include "AES.h"
#include "CreateException.h"
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <string.h>
#include <stdint.h>
#include "crc32.h"


const int signatureSize = 4;
const int recordHeaderSize = 6;
const int cipherBlockSize = 16;
const int endOfFrameRecordSize = 1;


//=============================================================================
// Constructor

OutputWriter::OutputWriter(MemoryMap *flash, MemoryMap *eeprom,
	unsigned int pageSize, DataBuffer *key, DataBuffer& initialVector,
	DataBuffer& signature, bool updateLockBits, unsigned char lockBits,
	unsigned int memSize, int keyCount, bool createFlashCRC, bool app32BitCrc, bool eraseFlash,
	bool nonsenseRecords
	) :

    crcPoly(app32BitCrc ? 0x1021 : 0x8005),

	aesM(new Aes(initialVector, keyCount)),

	// Maximum frame size can be calculated from the AVR page size
	frameMaxSizeM(
		((signatureSize + recordHeaderSize + pageSize + endOfFrameRecordSize)
			+ (cipherBlockSize - 1)
		) / cipherBlockSize * cipherBlockSize),

	// Maximum size of one record (maximum payload of one frame)
	recordMaxSizeM(frameMaxSizeM - signatureSize - endOfFrameRecordSize),

	// Number of bytes that must to be allocated from the SRAM of the target
	// AVR for reception buffer.
	bufferSizeM(2 + frameMaxSizeM + 2),

	pageSizeM(pageSize),
	memSizeM(memSize), 

	flashM(flash),
	eepromM(eeprom),

	initialVectorM(DataBuffer(initialVector)),
	signatureM(DataBuffer(signature)),

	frameBufferM(DataBuffer()),

	keyCountM(keyCount),
	keyM(key),

	updateLockBitsM(updateLockBits),
	lockBitsM(lockBits),

	createFlashCRCM(createFlashCRC),
	eraseFlashM(eraseFlash),
	nonsenseProbabilityM(nonsenseRecords ? 1 : 0)

{
	if( keyCountM > 0 ) {
		aesM->scheduleKey(key);
	}

	if (createFlashCRCM && flashM)
	{
		if (app32BitCrc)
		{	

			// Calculates the CRC of Application Section and inserts it to the
			// MemoryMap of the flash memory
			//unsigned int address;
			uint32_t crcCode = 0;
			DataBuffer crcBuffer;

			flashM->insert(memSizeM, crcBuffer);

			crcCode = crc32(flashM->buf, memSizeM-4);

			crcBuffer += (unsigned char)(crcCode );
			crcBuffer += (unsigned char)(crcCode >> 8);
			crcBuffer += (unsigned char)(crcCode >> 16);
			crcBuffer += (unsigned char)(crcCode >> 24);

			flashM->insert(memSizeM - 4, crcBuffer);

			uint32_t a = crc32(flashM->buf, memSizeM);

			if (a != 0)
				printf("error");
		}
		else
		{
			// Calculates the CRC of Application Section and inserts it to the
			// MemoryMap of the flash memory
			unsigned int address;
			unsigned short crcCode = 0;
			DataBuffer crcBuffer;

			for (address = 0; address < memSizeM - 2; address++)
				crcCode = crc(flashM->at(address), crcCode);

			crcCode = crc(0, crcCode);
			crcCode = crc(0, crcCode);

			crcBuffer += (unsigned char)(crcCode >> 8);
			crcBuffer += (unsigned char)(crcCode & 0xff);

			flashM->insert(memSizeM - 2, crcBuffer);		
		}
	}
}


//=============================================================================
// Destructor

OutputWriter::~OutputWriter()
{
	delete aesM;
}


//=============================================================================
// Write a AES key file for 'bootldr'.

// The following does not necessarily print well (line wraps)!
const char keyFileComment[] =
{
"//==============================================================================\n"
"// File:           %s\n"
"// Compiler:       IAR Atmel AVR C/EC++ Compiler\n"
"// Output Size:    %d\n"
"// Created:        %s\n"
"//\n"
"// Description:    This file is generated by 'create' tool and is to be included\n"
"//                 in the 'bootldr' project. It contains a AES key table for\n"
"//                 a proper decryption of the file encrypted using the same\n"
"//                 configurations.\n"
"//\n"
"// Keys used:      KEY1 = %s\n"
"//                 KEY2 = %s\n"
"//                 KEY3 = %s\n"
"//==============================================================================\n"
"\n"
"\n"
};


void OutputWriter::writeKeyFile(char *filename)
{
	FILE *keyFile;
	int lines = 1 + keyCountM;
	int i;

	char fnamebuf[256];
	strcpy( fnamebuf, filename );

	if ( (keyFile = fopen(filename, "w")) != NULL )
	{
		char * dateString;
		time_t rawtime = time(NULL);
		dateString = ctime( &rawtime );
//		_strdate(dateString);

		// Remove path from the filename
		char * filenameStripped, * token;
		token = strtok( fnamebuf, "\\/" );
		while( token ) {
			filenameStripped = token;
			token = strtok( NULL, "\\/" );
		}

		// Print comment area
		fprintf(keyFile, keyFileComment, filenameStripped, (8+keyCountM*8),
			dateString,
			((keyCountM > 0) ? keyM[0].toHexString() : "N/A"),
			((keyCountM > 1) ? keyM[1].toHexString() : "N/A"),
			((keyCountM > 2) ? keyM[2].toHexString() : "N/A")
		);

		// Print key 1 data
		if (keyCountM > 0) {
			fprintf(keyFile, "%s unsigned char kTable[%d] = \n{\n",
				((memSizeM > 65536) ? "__farflash" : "__flash"), 8+keyCountM*8);

			for (i = 0; i < 2; i++, lines--)
				fprintf(keyFile, lines ? "\t%s,\n" : "\t%s\n",
					aesM->getK(0, i*8).toCHexString());
		}

		// Print key 2 data
		if (keyCountM > 1)
		{
			fprintf(keyFile, "\n");
			
			for (i = 0; i < 1; i++, lines--)
				fprintf(keyFile, lines ? "\t%s,\n" : "\t%s\n",
					aesM->getK(1, i*8).toCHexString());
		}

		// Print key 3 data
		if (keyCountM > 2)
		{
			fprintf(keyFile, "\n");

			for (i = 0; i < 1; i++, lines--)
				fprintf(keyFile, lines ? "\t%s,\n" : "\t%s\n",
					aesM->getK(2, i*8).toCHexString());
		}

		if( keyCountM > 0 ) {
			fprintf(keyFile, "};\n");
		}

		fclose(keyFile);
	}
	else
		throw new CreateException(ERROR_CREATE_FILE, filename);
}


//=============================================================================
// Writes a header file for 'bootldr' containing all information necessary to
// customize the boot loader for a specific AVR and AES keys.

const char headerFileComment[] =
{
"//==============================================================================\n"
"// File:           %s\n"
"// Compiler:       IAR Atmel AVR C/EC++ Compiler\n"
"// Output Size:    -\n"
"// Created:        %s\n"
"//\n"
"// Description:    This file is generated by 'create' tool and is to be included\n"
"//                 in the 'bootldr' project. It contains the settings to\n"
"//                 configure the boot loader according to the configurations\n"
"//                 used in the encrypted file.\n"
"//==============================================================================\n"
"\n"
"\n"
};

void OutputWriter::writeHeaderFile(char *filename)
{
	FILE *headerFile;
	char fnamebuf[256];
	strcpy( fnamebuf, filename );

	if ( (headerFile = fopen(filename, "w")) != NULL )
	{
		char * dateString;
		time_t rawtime = time(NULL);
		dateString = ctime( &rawtime );
//		_strdate(dateString);

		// Remove path from the filename
		char * filenameStripped, * token;
		token = strtok( fnamebuf, "\\/" );
		while( token ) {
			filenameStripped = token;
			token = strtok( NULL, "\\/" );
		}

		// Write the comment in the beginning of the file
		fprintf(headerFile, headerFileComment, filenameStripped, dateString);

		// Convert 'filename.ext' to 'FILENAME_EXT'
		for( char * c = filenameStripped; *c; c++ ) toupper( *c );
//		_strupr(filenameStripped);
		char *dotIndex = strchr(filenameStripped, '.');
		*dotIndex = '_';

		fprintf(headerFile, "#ifndef %s\n", filenameStripped);
		fprintf(headerFile, "#define %s\n\n\n", filenameStripped);

		// Write #define's
		fprintf(headerFile, "#define PAGE_SIZE %d\n", pageSizeM);
		fprintf(headerFile, "#define MEM_SIZE %d\n", memSizeM);
		
		if (createFlashCRCM)
			fprintf(headerFile, "#define CRC_CHECK\n");

		fprintf(headerFile, "#define SIGNATURE 0x%s\n",
			signatureM.toHexString());

		fprintf(headerFile, "#define BUFFER_SIZE %d\n", bufferSizeM);

		fprintf(headerFile, "#define INITIALVECTOR_3 0x%s\n",
			initialVectorM.toHexString(0, 4));

		fprintf(headerFile, "#define INITIALVECTOR_2 0x%s\n",
			initialVectorM.toHexString(4, 4));

		fprintf(headerFile, "#define INITIALVECTOR_1 0x%s\n",
			initialVectorM.toHexString(8, 4));

		fprintf(headerFile, "#define INITIALVECTOR_0 0x%s\n",
			initialVectorM.toHexString(12, 4));

		fprintf(headerFile, "#define KEY_COUNT %d\n", keyCountM);

		fprintf(headerFile, "\n\n#endif // %s\n", filenameStripped);

		fclose(headerFile);
	}
}


//=============================================================================
// Prepares and writes one frame.

void OutputWriter::writeFrame()
{
	// If no data to write -> do not write.
	if (frameBufferM.size() == 0)
		return;

	// Insert signature in front of the frame
	frameBufferM.insert(0, signatureM);

	// Insert 'End Of Frame' frame
	frameBufferM += (unsigned char)0x00;

	if (keyCountM > 0) {
		if( frameBufferM.size() % 16 ) {
			int fillsize = 16 - (frameBufferM.size() % 16);
			while( fillsize-- ) {
				frameBufferM += (unsigned char) rand();
			}
		}
		aesM->encryptBuffer(frameBufferM);
	}

	// Calculate CRC
	unsigned int crcCode = 0;

	for (ByteString::iterator i = frameBufferM.begin(); i != frameBufferM.end(); i++)
		crcCode = crc(*i, crcCode);
	
	crcCode = crc(0, crcCode);
	crcCode = crc(0, crcCode);

	// Append CRC
	frameBufferM += (unsigned char)(crcCode >> 8);
	frameBufferM += (unsigned char)(crcCode & 0xff);

	// Write first the frame size and then the frame (including CRC)
	fprintf(outputFileM, "%04X", frameBufferM.size());
	fprintf(outputFileM, "%s", frameBufferM.toHexString());

	// Erase frame buffer for the next frame
	frameBufferM.erase();
}


//=============================================================================
// Inserts a record into frame. If the frame is already too full, writes the
// old frame and start a new one.

void OutputWriter::insertRecord(DataBuffer& record)
{
	// Shall we create some nonsense records before the real record?
	if ((float)rand()/RAND_MAX < nonsenseProbabilityM)
	{
		// Use exponential distribution function for the number of
		// nonsense records (i.e. favor smaller number of nonsense records)
		for (
			float probability = 1.0;
			(float)rand()/RAND_MAX < probability;
			probability = 0.93 * probability)
		{
			// If there is no room for nonsense records, write the frame
			if (frameBufferM.size() == recordMaxSizeM)
				writeFrame();

			// Add one byte of nonsense
			frameBufferM += 
				(unsigned char)(
					rand() % (TYPE_NONSENSE_LAST - TYPE_NONSENSE_FIRST + 1) +
						TYPE_NONSENSE_FIRST
				);
		}
	}

	// Use exponential distribution function of probability for the decision
	// of creating nonsense records i.e. lower the chances of nonsense records
	// after each real record, so there is a bigger probability of creating
	// nonsense records in the beginning of the output file (which can be
	// guessed more easily than the rest of the file).
	nonsenseProbabilityM = nonsenseProbabilityM * 0.9;

	if (frameBufferM.size() + record.size() > recordMaxSizeM)
		writeFrame();

	frameBufferM.append(record);

	delete &record;
}


//=============================================================================
// Writes Application Section update data.

void OutputWriter::writeFlash()
{
	// Page address
	unsigned int pageAddress;

	// Start address of the first page containing data
	unsigned int lowPage = flashM->getLowestAddress() / pageSizeM * pageSizeM;

	// Start address of the page after the last page containing data
	unsigned int highPage =
		flashM->getHighestAddress() / pageSizeM * pageSizeM + pageSizeM - 1;
	
	for (pageAddress = lowPage; pageAddress <= highPage;
		pageAddress += pageSizeM)
	{
		bool dataOnPage = false;	// Data found from the current page?

		unsigned int index = 0;		// Index counter on this page

		while (index < pageSizeM)
		{
			if (flashM->in(pageAddress + index))
			{
				// Find the number of successive data bytes on this page, ...
				unsigned int lastindex = index;

				while ((lastindex < pageSizeM) &&
					flashM->in(pageAddress + lastindex)
				)
					lastindex++;

				unsigned int count = lastindex - index;

				// First data chunk found on this page?
				//   Yes ->
				//		The chunk fills the whole page?
				//			-> no need for preparing
				//		Flash erase requested?
				//			-> insert CSEG_ERASE record
				//		Otherwise:
				//			-> insert CSEG_PREPARE record
				if (!dataOnPage)
				{
					if (count < pageSizeM)
					{
						if (eraseFlashM)
							insertRecord(buildRecordErase(pageAddress));
						else
							insertRecord(buildRecordPrepare(pageAddress));
					}

					dataOnPage = true;
				}

				// ... wrap it inside a record and insert in the frame
				insertRecord(buildRecordWrite(pageAddress, index, count));

				// Update index
				index = lastindex;
			}
			else
				index++;
		}

		if (dataOnPage)
		{
			// If there was data on the page, insert PROGRAM record
			insertRecord(buildRecordProgram(pageAddress));
			//printf("written %i / %i\n", pageAddress+index, highPage);
		}
		else if (eraseFlashM)
			// There was no data on the page, but all pages are forced to get
			// erased (by sending an ERASE record)
			insertRecord(buildRecordErase(pageAddress));
	}
}


//=============================================================================
// Writes EEPROM update data.

void OutputWriter::writeEEPROM()
{
	// Scan through the whole eeprom memory map for data
	unsigned int address = eepromM->getLowestAddress();
	
	while (address <= eepromM->getHighestAddress())
	{
		// Data in eeprom at 'address'?
		if (eepromM->in(address))
		{
			// Find the number of successive data bytes, ...
			int lastAddress = address;

			// (also check that the number of successive bytes is less than
			// what fits into one frame, which is the flash page size)
			while (eepromM->in(lastAddress) &&
				((lastAddress - address) < pageSizeM))
				lastAddress++;

			// ... wrap it inside a record and insert in the frame
			insertRecord(buildRecordEEPROM(address, lastAddress - address));

			//printf("new eeprom record of %i\n", lastAddress - address);

			address = lastAddress;
		}
		else
			address++;
	}
}


//=============================================================================
// Writes lock bits record.

void OutputWriter::writeLockBits()
{
	insertRecord(buildRecordLockBitsWrite());
}


//=============================================================================
// Writes 'Reset software' record.

void OutputWriter::writeResetSW()
{
	insertRecord(buildRecordResetSW());
}


//=============================================================================
// Creates a new encrypted file named 'filename', inserts all data to be
// updated in the target AVR into file, and encrypts it using AES
// encryption algorithm.

void OutputWriter::writeOutputFile(char *filename)
{
	if ( (outputFileM = fopen(filename, "w")) != NULL )
	{
		// Write flash contents
		if (flashM)
			writeFlash();

		// Write EEPROM contents
		if (eepromM)
			writeEEPROM();

		// Write Lock Bits
		if (updateLockBitsM)
			writeLockBits();

		// End the programming by resetting the AVR
		writeResetSW();
		
		// Flush the frame buffer
		writeFrame();

		fclose(outputFileM);
	}
	else 
		throw new CreateException(ERROR_CREATE_FILE, filename);
}


//=============================================================================
// Update a CRC counter ('oldCRC') with 'ch'.

unsigned short OutputWriter::crc(unsigned char ch, unsigned short oldCRC)
{	
	int n;
	unsigned long m;

	m = ((unsigned long)oldCRC << 8) | ch;
	for (n = 0; n < 8; n++)
		if ((m <<= 1) & 0x1000000)
			m ^= ((unsigned int)crcPoly << 8);

	return (unsigned short)(m >> 8);
}



//=============================================================================
// Build a record.

DataBuffer& OutputWriter::buildRecord(RecordType type, int address, int size,
									  const DataBuffer& buffer)
{
	DataBuffer& record = *new DataBuffer(6 + buffer.size());

	//printf("record: ");
	//switch (type)
	//{
	//	case TYPE_EOF:
	//		printf("TYPE_EOF ");
	//		break;
	//	case TYPE_ERASE:
	//		printf("TYPE_ERASE ");
	//		break;
	//	case TYPE_PREPARE:
	//		printf("TYPE_PREPARE ");
	//		break;
	//	case TYPE_DATA:
	//		printf("TYPE_DATA ");
	//		break;
	//	case TYPE_PROGRAM:
	//		printf("TYPE_PROGRAM ");
	//		break;
	//	case TYPE_EEPROM:
	//		printf("TYPE_EEPROM ");
	//		break;
	//	case TYPE_LOCKBITS:
	//		printf("TYPE_LOCKBITS ");
	//		break;
	//	case TYPE_RESET:
	//		printf("TYPE_RESET ");
	//		break;
	//	case TYPE_NONSENSE_FIRST:
	//		printf("TYPE_NONSENSE_FIRST ");
	//		break;
	//	case TYPE_NONSENSE_LAST:
	//		printf("TYPE_NONSENSE_LAST ");
	//		break;
	//}
	//
	//printf("address: %lu, bits: %lu, size: %i\n", address, address >> 16, size);

	record[0] = type;
	record[1] = address >> 16;
	record[2] = address >> 8;
	record[3] = address;
	record[4] = size >> 8;
	record[5] = size;

	for (size_t i = 0; i < buffer.size(); i++)
		record[i + 6] = buffer[i];

	return record;
}


//=============================================================================
// Build a record for erasing and preparing an Application Section page for the
// following data chunk writes.

DataBuffer& OutputWriter::buildRecordErase(unsigned int pageAddress)
{
	return buildRecord(TYPE_ERASE, pageAddress, pageSizeM, DataBuffer());
}


//=============================================================================
// Build a record for preparing an Application Section page for the following
// data chunk writes.

DataBuffer& OutputWriter::buildRecordPrepare(unsigned int pageAddress)
{
	return buildRecord(TYPE_PREPARE, pageAddress, pageSizeM, DataBuffer());
}


//=============================================================================
// Build a record for writing a chunk of Application Section data.

DataBuffer& OutputWriter::buildRecordWrite(unsigned int pageAddress,
					   unsigned int index, size_t length)
{
	DataBuffer buffer(length);

//	printf("recordwrite: %i to %i (%i)\n", index, index+length, length);
	for (size_t i = 0; i < length; i++)
		buffer[i] = flashM->buf[pageAddress + index + i];

	return buildRecord(TYPE_DATA, index, length, buffer);
}


//=============================================================================
// Build a record for programming a page to flash memory.

DataBuffer& OutputWriter::buildRecordProgram(unsigned int pageAddress)
{
	return buildRecord(TYPE_PROGRAM, pageAddress, pageSizeM / 2, DataBuffer());
}


//=============================================================================
// Build a record for writing a chunk of EEPROM data.

DataBuffer& OutputWriter::buildRecordEEPROM(unsigned int address,
					    size_t length)
{
	DataBuffer buffer(length);

	for (size_t i = 0; i < length; i++)
		buffer[i] = eepromM->buf[address + i];

	return buildRecord(TYPE_EEPROM, address, length, buffer);
}


//=============================================================================
// Build a record for writing lock bits.

DataBuffer& OutputWriter::buildRecordLockBitsWrite()
{
	return buildRecord(TYPE_LOCKBITS, (int)lockBitsM << 16, rand(),
		DataBuffer());
}


//=============================================================================
// Build a record for reseting the SW (the last record to be sent).

DataBuffer& OutputWriter::buildRecordResetSW()
{
	return buildRecord(TYPE_RESET, rand(), rand(), DataBuffer());
}
